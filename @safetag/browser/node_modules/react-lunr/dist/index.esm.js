import React, { useState, useEffect, useMemo } from 'react';
import lunr from 'lunr';
import PropTypes from 'prop-types';
import memoize from 'memoize-one';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var InvalidIndexError = Error('Lunr index could not be parsed. Check that your index exists and is valid.');
var InvalidStoreError = Error('Lunr store could not be parsed. Check that your store exists and is valid.');
var useLunr = function useLunr(query, stringifiedIndex, stringifiedStore) {
  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      index = _useState2[0],
      setIndex = _useState2[1];

  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      store = _useState4[0],
      setStore = _useState4[1];

  useEffect(function () {
    if (!stringifiedIndex) throw InvalidIndexError;
    var parsedIndex = JSON.parse(stringifiedIndex);
    if (!parsedIndex) throw InvalidIndexError;
    setIndex(lunr.Index.load(parsedIndex));
  }, [stringifiedIndex]);
  useEffect(function () {
    if (!stringifiedStore) throw InvalidStoreError;
    var parsedStore = JSON.parse(stringifiedStore);
    if (!parsedStore) throw InvalidStoreError;
    setStore(parsedStore);
  }, [stringifiedStore]);
  return useMemo(function () {
    if (!query || !index || !store) return [];
    var lunrResults = index.search(query);
    return lunrResults.map(function (_ref) {
      var ref = _ref.ref;
      return store[ref];
    });
  }, [query, index, store]);
};

var Lunr =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Lunr, _React$Component);

  _createClass(Lunr, null, [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      return {
        query: props.query
      };
    }
  }]);

  function Lunr(props) {
    var _this;

    _classCallCheck(this, Lunr);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Lunr).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "setQuery", function (query) {
      return _this.setState({
        query: query
      });
    });

    _defineProperty(_assertThisInitialized(_this), "search", memoize(function (query) {
      if (!query) return [];

      var results = _this.index.search(query);

      return results.map(function (_ref) {
        var ref = _ref.ref;
        return _this.store[ref];
      });
    }));

    _this.state = {
      query: props.initialQuery
    };
    _this.index = lunr.Index.load(JSON.parse(props.index));
    _this.store = JSON.parse(props.store);
    return _this;
  }

  _createClass(Lunr, [{
    key: "render",
    value: function render() {
      return this.props.children({
        query: this.state.query,
        setQuery: this.setQuery,
        results: this.search(this.state.query)
      });
    }
  }]);

  return Lunr;
}(React.Component);

_defineProperty(Lunr, "propTypes", {
  children: PropTypes.func.isRequired,
  index: PropTypes.string.isRequired,
  store: PropTypes.string.isRequired,
  initialQuery: PropTypes.string
});

_defineProperty(Lunr, "defaultProps", {
  initialQuery: ''
});

export { useLunr, Lunr };
